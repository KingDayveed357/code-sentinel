// src/ai/vulnerability-explainer.ts
// ============================================================================
// VULNERABILITY EXPLAINER SERVICE
// ============================================================================
// Provides AI-powered explanations for vulnerabilities using Claude/Gemini
// This is an optional service that requires ANTHROPIC_API_KEY or GEMINI_API_KEY
// ============================================================================

import type { FastifyInstance } from 'fastify';

export interface AIExplanation {
  summary: string;
  impact: string;
  remediation: string;
  references: string[];
  generated_at: string;
  model_version: string;
}

export interface VulnerabilityContext {
  title: string;
  description: string;
  severity: string;
  scanner_type: string;
  rule_id: string;
  cwe?: string | null;
  file_path?: string | null;
  code_snippet?: string | null;
}

export class VulnerabilityExplainerService {
  constructor(private fastify: FastifyInstance) {
    this.fastify.log.info('VulnerabilityExplainerService initialized');
  }

  /**
   * Generate AI explanation for a vulnerability
   */
  async explainVulnerability(context: VulnerabilityContext): Promise<AIExplanation> {
    const startTime = Date.now();
    
    try {
      // Check if AI service is available
      if (!process.env.ANTHROPIC_API_KEY && !process.env.GEMINI_API_KEY) {
        throw new Error('No AI API key configured');
      }

      // For now, return a structured fallback explanation
      // TODO: Implement actual AI integration when needed
      const explanation: AIExplanation = {
        summary: this.generateFallbackSummary(context),
        impact: this.generateFallbackImpact(context),
        remediation: this.generateFallbackRemediation(context),
        references: this.generateReferences(context),
        generated_at: new Date().toISOString(),
        model_version: 'fallback-v1',
      };

      this.fastify.log.debug({
        duration_ms: Date.now() - startTime,
        rule_id: context.rule_id,
        severity: context.severity,
      }, 'Generated vulnerability explanation');

      return explanation;
    } catch (error: any) {
      this.fastify.log.error({
        error: error.message,
        rule_id: context.rule_id,
      }, 'Failed to generate vulnerability explanation');
      
      throw error;
    }
  }

  private generateFallbackSummary(context: VulnerabilityContext): string {
    return context.description || `${context.title} detected in your codebase.`;
  }

  private generateFallbackImpact(context: VulnerabilityContext): string {
    const severityImpact = {
      critical: 'This vulnerability poses a critical security risk and should be addressed immediately.',
      high: 'This vulnerability poses a significant security risk and should be addressed as soon as possible.',
      medium: 'This vulnerability poses a moderate security risk and should be addressed in a timely manner.',
      low: 'This vulnerability poses a minor security risk but should still be reviewed.',
      info: 'This is an informational finding that may indicate a potential security concern.',
    };

    return severityImpact[context.severity as keyof typeof severityImpact] || 
           'This vulnerability should be reviewed and addressed appropriately.';
  }

  private generateFallbackRemediation(context: VulnerabilityContext): string {
    const typeRemediation = {
      sast: 'Review the code at the identified location and apply secure coding practices.',
      secret: 'Immediately rotate the exposed secret and remove it from the codebase. Use environment variables or a secrets manager.',
      sca: 'Update the vulnerable dependency to a patched version or find an alternative package.',
      iac: 'Review and update the infrastructure configuration to follow security best practices.',
      container: 'Update the base image or vulnerable package in your container.',
    };

    return typeRemediation[context.scanner_type as keyof typeof typeRemediation] || 
           'Review and remediate the vulnerability according to security best practices.';
  }

  private generateReferences(context: VulnerabilityContext): string[] {
    const references: string[] = [];

    if (context.cwe) {
      references.push(`https://cwe.mitre.org/data/definitions/${context.cwe.replace('CWE-', '')}.html`);
    }

    if (context.rule_id) {
      // Add scanner-specific reference links
      if (context.scanner_type === 'sast') {
        references.push(`https://semgrep.dev/r/${context.rule_id}`);
      }
    }

    return references;
  }
}
