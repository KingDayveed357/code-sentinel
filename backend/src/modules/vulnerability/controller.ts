// src/modules/vulnerability/controller.ts - FIXED
import type { FastifyRequest, FastifyReply } from "fastify";
import * as service from "./service";
import {
  vulnerabilityListSchema,
  scanIdSchema,
  scanAndTypeSchema,
  vulnerabilityDetailsSchema,
  updateVulnerabilityStatusSchema,
  repoIdSchema,
} from "./schemas";
import { createGitHubIssue } from "../github-issues/service";

export async function getVulnerabilitiesByScanController(
  request: FastifyRequest<{ Params: any; Querystring: any }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { scanId } = scanIdSchema.parse(request.params);
  const filters = vulnerabilityListSchema.parse(request.query);

  const result = await service.getVulnerabilitiesByScan(
    request.server,
    workspaceId,
    scanId,
    filters,
  );

  return reply.send(result);
}

export async function getVulnerabilitiesByScanAndTypeController(
  request: FastifyRequest<{ Params: any; Querystring: any }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { scanId, type } = scanAndTypeSchema.parse(request.params);
  const filters = vulnerabilityListSchema.parse(request.query);

  const result = await service.getVulnerabilitiesByScanAndType(
    request.server,
    workspaceId,
    scanId,
    type,
    filters,
  );

  return reply.send(result);
}

export async function getVulnerabilityDetailsController(
  request: FastifyRequest<{ Params: any }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { id, type } = vulnerabilityDetailsSchema.parse(request.params);

  const result = await service.getVulnerabilityDetails(
    request.server,
    workspaceId,
    id,
    type,
  );

  return reply.send(result);
}

export async function updateVulnerabilityStatusController(
  request: FastifyRequest<{ Params: any; Body: any }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { id, type } = vulnerabilityDetailsSchema.parse(request.params);
  const { status, note } = updateVulnerabilityStatusSchema.parse(request.body);

  const result = await service.updateVulnerabilityStatus(
    request.server,
    workspaceId,
    id,
    type,
    status,
    note,
  );

  return reply.send(result);
}

export async function getRepositoryStatsController(
  request: FastifyRequest<{ Params: any }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { repoId } = repoIdSchema.parse(request.params);

  const result = await service.getRepositoryStats(
    request.server,
    workspaceId,
    repoId,
  );

  return reply.send(result);
}

export async function createGitHubIssueController(
  request: FastifyRequest<{ Params: { type: string; id: string } }>,
  reply: FastifyReply,
) {
  const workspace = (request as any).workspace;
  if (!workspace || !workspace.id) {
    throw request.server.httpErrors.unauthorized(
      "Workspace missing from request",
    );
  }
  const workspaceId = workspace.id;
  const { type, id } = request.params;

  // Validate type
  const validTypes = ["sast", "sca", "secrets", "iac", "container"];
  if (!validTypes.includes(type)) {
    throw request.server.httpErrors.badRequest("Invalid vulnerability type");
  }

  // Get vulnerability with scan and repository context
  const { data: vuln, error } = await request.server.supabase
    .from(`vulnerabilities_${type}`)
    .select(
      `
      *,
      scans!inner(
        id,
        repository_id,
        branch,
        commit_sha,
        repositories!inner(
          full_name,
          owner
        )
      )
    `,
    )
    .eq("id", id)
    .eq("workspace_id", workspaceId)
    .single();

  if (error || !vuln) {
    throw request.server.httpErrors.notFound("Vulnerability not found");
  }

  // Check if issue already exists
  const { data: existingIssue } = await request.server.supabase
    .from("github_issues")
    .select("github_issue_url, github_issue_number")
    .eq("vulnerability_id", id)
    .eq("vulnerability_type", type)
    .eq("issue_status", "open")
    .single();

  if (existingIssue) {
    return reply.send({
      success: true,
      issue_url: existingIssue.github_issue_url,
      issue_number: existingIssue.github_issue_number,
      message: "Issue already exists",
    });
  }

  // Create GitHub issue
  const result = await createGitHubIssue(
    request.server,
    workspaceId,
    {
      id: vuln.id,
      type: type as any,
      severity: vuln.severity,
      title: vuln.title,
      description: vuln.description,
      file_path: vuln.file_path,
      line_start: vuln.line_start,
      recommendation: vuln.recommendation || vuln.ai_remediation,
      cwe: vuln.cwe,
      cve: vuln.cve,
    },
    {
      scanId: vuln.scans.id,
      repositoryId: vuln.scans.repository_id,
      repoFullName: vuln.scans.repositories.full_name,
      branch: vuln.scans.branch,
      commitSha: vuln.scans.commit_sha,
    },
    {
      auto: false,
    },
  );

  if (!result.success) {
    throw request.server.httpErrors.internalServerError(
      result.error || "Failed to create GitHub issue",
    );
  }

  return reply.send(result);
}
