// src/modules/vulnerability/service.ts - FIXED: Scan-based queries
import type { FastifyInstance } from 'fastify';

/**
 * Get all vulnerabilities for a specific scan (across all types)
 */
export async function getVulnerabilitiesByScan(
  fastify: FastifyInstance,
  userId: string,
  scanId: string,
  filters: {
    severity?: string;
    status?: string;
    search?: string;
    page: number;
    limit: number;
  }
) {
  // First verify scan belongs to user
  const { data: scan } = await fastify.supabase
    .from('scans')
    .select('id, repository_id')
    .eq('id', scanId)
    .eq('user_id', userId)
    .single();

  if (!scan) {
    throw fastify.httpErrors.notFound('Scan not found');
  }

  const offset = (filters.page - 1) * filters.limit;

  const tables = [
    'vulnerabilities_sast',
    'vulnerabilities_sca',
    'vulnerabilities_secrets',
    'vulnerabilities_iac',
    'vulnerabilities_container',
  ];

  const results = await Promise.all(
    tables.map((table) =>
      queryVulnerabilitiesByScan(fastify, scanId, table, filters, offset)
    )
  );

  // Merge and sort results
  const allVulns = results.flatMap((r) => r.data || []);
  const totalCount = results.reduce((sum, r) => sum + (r.count || 0), 0);

  // Sort by severity then detected_at
  allVulns.sort((a, b) => {
    const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
    const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
    if (severityDiff !== 0) return severityDiff;
    
    const dateA = new Date(a.detected_at || 0).getTime();
    const dateB = new Date(b.detected_at || 0).getTime();
    return dateB - dateA;
  });

  // Apply pagination to merged results
  const paginatedVulns = allVulns.slice(offset, offset + filters.limit);

  return {
    vulnerabilities: paginatedVulns,
    total: totalCount,
    page: filters.page,
    pages: Math.ceil(totalCount / filters.limit),
  };
}

/**
 * Get vulnerabilities by type for a specific scan
 */
export async function getVulnerabilitiesByScanAndType(
  fastify: FastifyInstance,
  userId: string,
  scanId: string,
  type: 'sast' | 'sca' | 'secrets' | 'iac' | 'container',
  filters: {
    severity?: string;
    status?: string;
    search?: string;
    page: number;
    limit: number;
  }
) {
  // Verify scan belongs to user
  const { data: scan } = await fastify.supabase
    .from('scans')
    .select('id')
    .eq('id', scanId)
    .eq('user_id', userId)
    .single();

  if (!scan) {
    throw fastify.httpErrors.notFound('Scan not found');
  }

  const table = getTableForType(type);
  const offset = (filters.page - 1) * filters.limit;

  const result = await queryVulnerabilitiesByScan(
    fastify,
    scanId,
    table,
    filters,
    offset
  );

  return {
    vulnerabilities: result.data || [],
    total: result.count || 0,
    page: filters.page,
    pages: Math.ceil((result.count || 0) / filters.limit),
  };
}

/**
 * Get single vulnerability details
 */
export async function getVulnerabilityDetails(
  fastify: FastifyInstance,
  userId: string,
  vulnerabilityId: string,
  type: 'sast' | 'sca' | 'secrets' | 'iac' | 'container'
) {
  const table = getTableForType(type);

  const { data, error } = await fastify.supabase
    .from(table)
    .select('*')
    .eq('id', vulnerabilityId)
    .eq('user_id', userId)
    .single();

  if (error || !data) {
    throw fastify.httpErrors.notFound('Vulnerability not found');
  }

  return { ...data, type };
}

/**
 * Update vulnerability status
 */
export async function updateVulnerabilityStatus(
  fastify: FastifyInstance,
  userId: string,
  vulnerabilityId: string,
  type: 'sast' | 'sca' | 'secrets' | 'iac' | 'container',
  status: 'open' | 'in_review' | 'accepted' | 'false_positive' | 'wont_fix' | 'fixed',
  note?: string
) {
  const table = getTableForType(type);

  const updates: any = {
    status,
    updated_at: new Date().toISOString(),
  };

  if (status === 'fixed') {
    updates.resolved_at = new Date().toISOString();
  }

  if (note) {
    updates.triage_note = note;
    updates.triaged_by = userId;
    updates.triaged_at = new Date().toISOString();
  }

  const { data, error } = await fastify.supabase
    .from(table)
    .update(updates)
    .eq('id', vulnerabilityId)
    .eq('user_id', userId)
    .select()
    .single();

  if (error || !data) {
    throw fastify.httpErrors.notFound('Vulnerability not found');
  }

  return data;
}

/**
 * Get repository-level stats (across all scans)
 */
export async function getRepositoryStats(
  fastify: FastifyInstance,
  userId: string,
  repositoryId: string
) {
  const tables = [
    'vulnerabilities_sast',
    'vulnerabilities_sca',
    'vulnerabilities_secrets',
    'vulnerabilities_iac',
    'vulnerabilities_container',
  ];

  const results = await Promise.all(
    tables.map(async (table) => {
      const { count } = await fastify.supabase
        .from(table)
        .select('id', { count: 'exact', head: true })
        .eq('user_id', userId)
        .eq('repository_id', repositoryId);

      return { table, count: count || 0 };
    })
  );

  // Count by severity
  const severityCounts = await Promise.all(
    ['critical', 'high', 'medium', 'low', 'info'].map(async (severity) => {
      const counts = await Promise.all(
        tables.map(async (table) => {
          const { count } = await fastify.supabase
            .from(table)
            .select('id', { count: 'exact', head: true })
            .eq('user_id', userId)
            .eq('repository_id', repositoryId)
            .eq('severity', severity);

          return count || 0;
        })
      );

      return { severity, count: counts.reduce((sum, c) => sum + c, 0) };
    })
  );

  const byType = {
    sast: results.find((r) => r.table === 'vulnerabilities_sast')?.count || 0,
    sca: results.find((r) => r.table === 'vulnerabilities_sca')?.count || 0,
    secrets: results.find((r) => r.table === 'vulnerabilities_secrets')?.count || 0,
    iac: results.find((r) => r.table === 'vulnerabilities_iac')?.count || 0,
    container: results.find((r) => r.table === 'vulnerabilities_container')?.count || 0,
  };

  const bySeverity = severityCounts.reduce(
    (acc, { severity, count }) => {
      acc[severity] = count;
      return acc;
    },
    {} as Record<string, number>
  );

  return {
    total: Object.values(byType).reduce((sum, c) => sum + c, 0),
    by_type: byType,
    by_severity: bySeverity,
  };
}

/**
 * Helper: Query vulnerabilities for a specific scan
 */
async function queryVulnerabilitiesByScan(
  fastify: FastifyInstance,
  scanId: string,
  table: string,
  filters: any,
  offset: number
) {
  let query = fastify.supabase
    .from(table)
    .select('*', { count: 'exact' })
    .eq('scan_id', scanId)
    .order('detected_at', { ascending: false });

  if (filters.severity) {
    query = query.eq('severity', filters.severity);
  }

  if (filters.status) {
    query = query.eq('status', filters.status);
  }

  if (filters.search) {
    query = query.or(
      `title.ilike.%${filters.search}%,description.ilike.%${filters.search}%,file_path.ilike.%${filters.search}%`
    );
  }

  query = query.range(offset, offset + filters.limit - 1);

  const { data, error, count } = await query;

  if (error) {
    fastify.log.error({ error, table, scanId }, 'Failed to fetch vulnerabilities');
    throw fastify.httpErrors.internalServerError('Failed to fetch vulnerabilities');
  }

  return { data, count };
}

function getTableForType(type: string): string {
  const tableMap: Record<string, string> = {
    sast: 'vulnerabilities_sast',
    sca: 'vulnerabilities_sca',
    secrets: 'vulnerabilities_secrets',
    iac: 'vulnerabilities_iac',
    container: 'vulnerabilities_container',
  };

  return tableMap[type] || 'vulnerabilities_sast';
}